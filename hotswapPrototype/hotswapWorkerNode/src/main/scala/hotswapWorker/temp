import akka.actor._
import scala.collection.mutable.{HashSet, HashMap}

@protocol
object MasterWorkerProtocol {
  /** Initialization message for worker nodes that contains the list of 
    * prefixes that determine the set of "dangerous" classes.
    *
    */
  @direction(
    from = classOf[Master], 
    to =   classOf[Worker]
  )
  case class Initialize(dangerousClasses: List[String])

  /** Job serialized as byte array
    *
    */
  @direction(
    from = classOf[Master], 
    to =   classOf[Worker]
  )
  case class SerializedJob(bytes: Array[Byte])

  /** Asks the worker to attempt to stop all `Containment`s that have
    * loaded
    *
    */
  @direction(
    from = classOf[Master], 
    to =   classOf[Worker]
  )
  case class TryToStop(className: String)
}

@protocol
object ContainmentWorkerProtocol {
  
  /** Tells the containment to load and execute a job
    *
    */
  @direction(
    from = classOf[Worker],
    to   = classOf[Containment]
  )
  case class Job(serializedRepresentation: Array[Byte])

  /** A message sent by a Containment to WorkerNodeManager after the 
    * worker receives a serialized job and loads the relevant classes.
    */
  @direction(
    from = classOf[Containment],
    to   = classOf[Worker]
  )
  case class JobAccepted(loadedDangerousClasses: Array[String])

  
}

class Worker(numWorkers: Int) extends Actor {
  private val containments: HashSet[ActorRef] = {
    for (i <- 1 to numWorkers) yield {
      context.actorOf(Containment.props, "worker_" + i)
    }
  }

  private val freeWorkers: HashSet[ActorRef] = HashSet(workerPool)

  private val loadedIsolatedClasses: HashMap[ActorRef, Array[String]] =
    HashMap.empty[ActorRef, Array[String]] ++ 
    (for (w <- workerPool) yield {
      (w, Array[String]())
    })

  def workerReceive = ({
    case JobAccepted(dangerousClasses: Array[String]) => {
      
    }
  } : Receive)

  def masterReceive = ({
    case Freeze(badClass) => {
      for ((x, y) <- loadedIsolatedClasses) {
        if (y.contains(badClass)) {
          // CONTINUE HERE: context.actorOf etc...
        }
      }
    }
  } : Receive)

  def handleUnexpected = ({
    case sthUnexpected => log.warning(
      "Unexpected message of type " + sthUnexpected.getClass + " with value: " + 
      sthUnexpected
    )
  } : Receive)

  def receive = 
    masterReceive orElse
    workerReceive orElse
    handleUnexpected
}

object Worker {
  def props(n: Int) = Props(classOf[Worker], n)
}

/** An actor spawned by the worker node which can contain "dangerous" 
  * code (i.e. code that is likely to crash).
  */
class Containment extends Actor { self =>
  import ContainmentWorkerProtocol._
  def receive = ({
    case SerializedJob(bytes) => {
      val bais = new java.io.ByteArrayInputStream(bytes)
      val cl = new IsolatingClassLoader(
        self.getClass.getClassLoader,
        Array("Job")
      )
      val icois = new IsolatingClassObjectInputStream(bais, cl)
      val j: Job = icois.readObject().asInstanceOf[Job]
      j.doJob()
      println("Potentially reloadable classes: " + icois.loadedIsolatedClasses)
    }
    case sthElse => println("Received unexpected: " + sthElse)
  }: Receive)
}

object Containment {
  def props: Props = Props(classOf[Containment])
}

object WorkerMain {
  def main(args: Array[String]): Unit = {
    println("Starting Worker actor system")
    val sys = ActorSystem("workersystem")
    val worker = sys.actorOf(Worker.props(5))
    worker ! "hello there!"
  }
}